<!DOCTYPE html>
<html lang="en" class="no-js">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta http-equiv="x-ua-compatible" content="ie=edge">
<meta name="description" content="manual">
<meta name="generator" content="Paradox, paradox-material-theme=0.6.0, mkdocs-material=3.0.3">

<meta name="lang:clipboard.copy" content="Copy to clipboard">
<meta name="lang:clipboard.copied" content="Copied to clipboard">
<meta name="lang:search.language" content="">
<meta name="lang:search.pipeline.stopwords" content="true">
<meta name="lang:search.pipeline.trimmer" content="true">
<meta name="lang:search.result.none" content="No matching documents">
<meta name="lang:search.result.one" content="1 matching document">
<meta name="lang:search.result.other" content="# matching documents">
<meta name="lang:search.tokenizer" content="[\s\-]+">


<meta name="description" content="manual">
<link rel="shortcut icon" href="../assets/images/favicon.png">
<title>Application-specific authentication Â· endpoints4s</title>
<link rel="stylesheet" href="../assets/stylesheets/application.451f80e5.css">
<link rel="stylesheet" href="../lib/material__tabs/dist/mdc.tabs.min.css">
<link rel="stylesheet" href="../lib/prettify/prettify.css">
<script src="../assets/javascripts/modernizr.1aa3b519.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono">
<style>
body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}
code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}
</style>
<link rel="stylesheet" href="../assets/fonts/font-awesome.css">
<link rel="stylesheet" href="../assets/fonts/material-icons.css">
<link rel="stylesheet" href="../assets/stylesheets/paradox-material-theme.css">
<link rel="stylesheet" href="../snippets.css">
</head>
<body
>
<input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
<input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
<label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
<header class="md-header" data-md-component="header">
<nav class="md-header-nav md-grid">
<div class="md-flex">
<div class="md-flex__cell md-flex__cell--shrink">
<a href="../index.html" title="endpoints4s" class="md-header-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
</div>
<div class="md-flex__cell md-flex__cell--stretch">
<div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
<span class="md-header-nav__topic">
endpoints4s
</span>
<span class="md-header-nav__topic">
Application-specific authentication
</span>
</div>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
<label class="md-icon md-search__icon" for="__search"></label>
<button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">&#xE5CD;</button>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix>
<div class="md-search-result" data-md-component="result">
<div class="md-search-result__meta">
Type to start searching
</div>
<ol class="md-search-result__list"></ol>
</div>
</div>
</div>
</div>
</div>

</div>
<div class="md-flex__cell md-flex__cell--shrink">
<div class="md-header-nav__source">
<a href="https://github.com/endpoints4s/endpoints4s"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
endpoints4s/endpoints4s
</div>
</a>

</div>
</div>
</div>
</nav>
</header>

<div class="md-container">
<main class="md-main">
<div class="md-main__inner md-grid" data-md-component="container">
<div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--primary" data-md-level="0" style="visibility: hidden">
<label class="md-nav__title md-nav__title--site" for="drawer">
<a href="../index.html" title="endpoints4s" class="md-nav__button md-logo">
<span class="md-nav__button md-logo">
<i class="md-icon">local_library</i>
</a>
<a href="../index.html" title="endpoints4s">
endpoints4s
</a>
</label>
<div class="md-nav__source">
<a href="https://github.com/endpoints4s/endpoints4s"
title="Go to repository"
class="md-source"
data-md-source="github">
<div class="md-source__icon">
<i class="fa fa-github"></i>
</div>
<div class="md-source__repository">
endpoints4s/endpoints4s
</div>
</a>

</div>
<ul>
  <li><a href="../use-cases.html" class="page">Use Cases</a></li>
  <li><a href="../quick-start.html" class="page">Quick start</a></li>
  <li><a href="../design.html" class="page">Design in a nutshell</a></li>
  <li><a href="../algebras-and-interpreters.html" class="page">Algebras and interpreters</a>
  <ul>
    <li><a href="../algebras/endpoints.html" class="page"><code>Endpoints</code></a></li>
    <li><a href="../algebras/json-entities.html" class="page">JSON Entities</a></li>
    <li><a href="../algebras/json-schemas.html" class="page">JSON Schemas</a></li>
    <li><a href="../algebras/chunked-entities.html" class="page">Chunked Entities</a></li>
    <li><a href="../algebras/middlewares.html" class="page">Middlewares</a></li>
    <li><a href="../algebras/assets.html" class="page">Assets</a></li>
    <li><a href="../algebras/mux-endpoints.html" class="page">Multiplexed Endpoints</a></li>
    <li><a href="../interpreters/akka-http.html" class="page">Akka HTTP</a></li>
    <li><a href="../interpreters/http4s.html" class="page">http4s</a></li>
    <li><a href="../interpreters/scalajs-web-xhr.html" class="page">Scala.js web client (XHR)</a></li>
    <li><a href="../interpreters/scalajs-web-fetch.html" class="page">Scala.js web client (Fetch)</a></li>
    <li><a href="../interpreters/sttp.html" class="page">sttp</a></li>
    <li><a href="../interpreters/openapi.html" class="page">OpenAPI</a></li>
    <li><a href="../interpreters/circe.html" class="page">Circe</a></li>
    <li><a href="../interpreters/play-json.html" class="page">Play JSON</a></li>
  </ul></li>
  <li><a href="../guides.html" class="page">Guides</a>
  <ul>
    <li><a href="../guides/tupler.html" class="page"><code>Tupler</code></a></li>
    <li><a href="../guides/custom-authentication.html" class="active page">Application-specific authentication</a></li>
  </ul></li>
  <li><a href="../community.html" class="page">Community</a></li>
  <li><a href="../comparison.html" class="page">Comparison with similar tools</a></li>
  <li><a href="../talks.html" class="page">Talks and Articles</a></li>
  <li><a href="../release-and-compatibility-notes.html" class="page">Release and Compatibility Notes</a></li>
</ul>
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../guides/custom-authentication.html#application-specific-authentication" class="header">Application-specific authentication</a>
  <ul>
    <li><a href="../guides/custom-authentication.html#authentication-flow" class="header">Authentication flow</a></li>
    <li><a href="../guides/custom-authentication.html#login-endpoint" class="header">Login endpoint</a></li>
    <li><a href="../guides/custom-authentication.html#protected-endpoints" class="header">Protected endpoints</a></li>
    <li><a href="../guides/custom-authentication.html#conclusion" class="header">Conclusion</a></li>
  </ul></li>
</ul>
</nav>

</nav>
<ul style="display: none">
<li class="md-nav__item md-version" id="project.version">
<label class="md-nav__link" for="__version">
<i class="md-icon" title="Version">label_outline</i> 1.9.0
</label>
</li>
</ul>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">Table of contents</label>
<ul>
  <li><a href="../guides/custom-authentication.html#application-specific-authentication" class="header">Application-specific authentication</a>
  <ul>
    <li><a href="../guides/custom-authentication.html#authentication-flow" class="header">Authentication flow</a></li>
    <li><a href="../guides/custom-authentication.html#login-endpoint" class="header">Login endpoint</a></li>
    <li><a href="../guides/custom-authentication.html#protected-endpoints" class="header">Protected endpoints</a></li>
    <li><a href="../guides/custom-authentication.html#conclusion" class="header">Conclusion</a></li>
  </ul></li>
</ul>
</nav>

</div>
</div>
</div>
<div class="md-content">
<article class="md-content__inner md-typeset">
<div class="md-content__searchable">
<h1><a href="#application-specific-authentication" name="application-specific-authentication" class="anchor"><span class="anchor-link"></span></a>Application-specific authentication</h1>
<p>This page explains how to extend the <code>Endpoints</code> algebra with vocabulary specific to the authentication mechanism used by an application, and how to extend interpreters to implement this authentication mechanism for the server side and the client side.</p>
<p>We will be using http4s but the same approach can be used for other HTTP libraries.</p>
<p>We focus on authentication but the same approach can be used for any other application-specific aspect of the communication that needs to be consistently implemented by clients and servers.</p>
<h2><a href="#authentication-flow" name="authentication-flow" class="anchor"><span class="anchor-link"></span></a>Authentication flow</h2>
<p>In this example, the authentication information will be encoded in a JSON Web Token (JWT) attached to HTTP requests. The client will first login to the server, to get its JWT, and then will use the JWT issued by the server to access to protected resources. This can be summarized by the following diagram:</p>
<p><img src="authentication-flow.svg" alt="authentication-flow" /></p>
<p>We want to enrich the endpoints4s algebras with new vocabulary describing the login endpoint as well as the protected endpoints.</p>
<h2><a href="#login-endpoint" name="login-endpoint" class="anchor"><span class="anchor-link"></span></a>Login endpoint</h2>
<p>Letâs start with the login endpoint. This endpoint takes requests containing credentials and returns responses containing the issued JWT, or an empty âBad Requestâ response in case the credentials where invalid.</p>
<h3><a href="#authentication-algebra" name="authentication-algebra" class="anchor"><span class="anchor-link"></span></a>Authentication algebra</h3>
<p>The existing algebras already provides all we need to describe such an endpoint, except for two things:</p>
<ul>
  <li>encoding the logged in user information as a JWT in the response,</li>
  <li>signalling a bad request in case the authentication failed.</li>
</ul>
<p>A JWT contains information about the logged-in user (for instance, his name), and that information is serialized and is cryptographically signed by the server (thatâs why clients can not forge an arbitrary JWT). In our case, the user information we are interested in is only its name:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L122" target="_blank" title="Go to snippet source">source</a><code class="language-scala">case class UserInfo(name: String)</code></pre>
<p>The type used to model the authentication token will be different on client-side and server-side. On server-side, we are only interested in the user info and we want to let the algebra interpreter serialize and sign it. However, on client-side we need to also keep the serialized form since clients can not compute it. Since we want to represent the same concept with different concrete types on the server and client sides, we model it in the algebra with an abstract type member <code>AuthenticationToken</code>.</p>
<p>In the end, we need to add the following members to our algebra:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L9-L117" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import endpoints4s.algebra
import endpoints4s.Codec

/** Algebra interface for defining authenticated endpoints using JWT.
  */
trait Authentication extends algebra.Endpoints with algebra.JsonEntitiesFromSchemas {

  /** Authentication information. It is left abstract because clients and
    * servers may want to use different representations
    */
  type AuthenticationToken

  /** A response containing a JWT in a JSON document. */
  final def authenticationToken: Response[AuthenticationToken] = {
    val authenticationTokenSchema =
      field[String](&quot;jwt_token&quot;)
        .xmapWithCodec(authenticationTokenCodec)
    ok(jsonResponse(authenticationTokenSchema))
  }

  /** Logic for decoding the JWT.
    * Servers validate the token signature, clients just decode without validating.
    */
  def authenticationTokenCodec: Codec[String, AuthenticationToken]

  /** A response that might signal to the client that his request was invalid using
    * a `BadRequest` status.
    * Clients map `BadRequest` statuses to `None`, and the underlying `response` into `Some`.
    * Conversely, servers build a `BadRequest` response on `None`, or the underlying `response` otherwise.
    */
  final def wheneverValid[A](responseA: Response[A]): Response[Option[A]] =
    responseA
      .orElse(response(BadRequest, emptyResponse))
      .xmap(_.fold[Option[A]](Some(_), _ =&gt; None))(_.toLeft(()))

}</code></pre>
<p>We define our algebra in a trait named <code>Authentication</code>, which extends the main algebra, <code>algebra.Endpoints</code>.</p>
<p>Given this new algebra, we can now describe the login endpoint as follows:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Usage.scala#L4-L45" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import endpoints4s.algebra

trait AuthenticationEndpoints extends algebra.Endpoints with Authentication {

  /** Login endpoint: takes the API key in a query string parameter and returns either `Some(authenticationToken)`
    * if the credentials are valid, or `None` otherwise
    */
  val login: Endpoint[String, Option[AuthenticationToken]] = endpoint(
    get(path / &quot;login&quot; /? qs[String](&quot;apiKey&quot;)),
    wheneverValid(authenticationToken)
  )

}</code></pre>
<p>The <code>login</code> endpoint is defined in an <code>AuthenticationTrait</code>, which uses (by inheritance) the main algebra, <code>algebra.Endpoints</code>, and the <code>Authentication</code> algebra.</p>
<p>The endpoint takes request using the <code>GET</code> method, the <code>/login</code> URL and a query string parameter <code>apiKey</code> containing the credentials. The returned response is either a âBad Requestâ, or a âOkâ with the issued authentication token.</p>
<h3><a href="#authentication-server-interpreter" name="authentication-server-interpreter" class="anchor"><span class="anchor-link"></span></a>Authentication server interpreter</h3>
<p>The server interpreter fixes the <code>AuthenticationToken</code> type member to <code>UserInfo</code> and implements the <code>authenticationTokenCodec</code> method:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L15-L303" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import endpoints4s.http4s.server
import pdi.jwt.JwtCirce

trait ServerAuthentication[F[_]]
    extends server.Endpoints[F]
    with server.JsonEntitiesFromSchemas
    with Authentication {

  def privateKey: PrivateKey
  def publicKey: PublicKey

  // On server side, we build the token ourselves so we only care about the user information
  type AuthenticationToken = UserInfo

  def decodeToken(token: String): Validated[UserInfo] =
    Validated.fromTry(
      JwtCirce
        .decode(token, publicKey)
        .flatMap { claim =&gt;
          io.circe.parser.parse(claim.content).toTry.flatMap(_.as[UserInfo].toTry)
        }
    )

  // Encodes the user info in the JWT session
  def authenticationTokenCodec: Codec[String, AuthenticationToken] =
    Codec.fromEncoderAndDecoder[String, AuthenticationToken] { authenticationToken =&gt;
      JwtCirce.encode(UserInfo.codec(authenticationToken), privateKey, JwtAlgorithm.RS256)
    }(decodeToken(_))

}</code></pre>
<p>The <code>ServerAuthentication</code> trait extends the <code>Authentication</code> algebra as well as a server <code>Endpoints</code> interpreter based on http4s.</p>
<p>The <code>authenticationTokenCodec</code> operation is implemented with the help of the library <a href="https://github.com/pauldijou/jwt-scala">pauldijou/jwt-scala</a>. It serializes the user info into JSON (via <code>UserInfo.codec</code>), and then creates a signed JWT from it with a private key.</p>
<p>With this interpreter, the implementation of the login endpoint looks like the following:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Usage.scala#L8-L99" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import endpoints4s.http4s.server

class Server
    extends server.Endpoints[IO]
    with AuthenticationEndpoints
    with ServerAuthentication[IO] {

    login.implementedBy { apiKey =&gt;
      if (apiKey == &quot;foobar&quot;) Some(UserInfo(&quot;Alice&quot;))
      else None
    }

}</code></pre>
<p>Our <code>Server</code> class extends the traits that defines the <code>login</code> endpoint, namely the <code>AuthenticationEndpoints</code>, and mixes the http4s-based server interpreter as well as our <code>ServerAuthentication</code> interpreter.</p>
<p>In this simplified example, we only have one valid API key, <code>&quot;foobar&quot;</code>, belonging to Alice. The <code>login</code> endpoint is implemented by a function that checks whether the supplied <code>apiKey</code> is equal to <code>&quot;foobar&quot;</code>, in which case it returns a <code>UserInfo</code> object wrapped in a <code>Some</code>. Otherwise, it returns <code>None</code> to signal that the API key is invalid.</p>
<h3><a href="#mid-way-summary" name="mid-way-summary" class="anchor"><span class="anchor-link"></span></a>Mid-way summary</h3>
<p>What have we learnt so far?</p>
<p>We are only halfway through this document but the first sections already showed the key aspects of enriching endpoints4s for application-specific needs:</p>
<ol>
  <li>We have <strong>enriched</strong> the existing algebras with another algebra,  by defining a trait extending the existing algebras;</li>
  <li>We have introduced new <strong>concepts</strong> as abstract type members (in  our case, <code>AuthenticationToken</code>);</li>
  <li>We have introduced new <strong>operations</strong> defining how to  build or combine concepts together;</li>
  <li>We have <strong>used</strong> our algebra to define descriptions of endpoints,  by defining a trait extending the algebra;</li>
  <li>We have implemented an <strong>interpreter</strong> for our algebra, by  defining a trait extending the algebra, mixing an existing  base interpreter and implementing the remaining abstract members;</li>
  <li>We have <strong>applied</strong> our interpreter to our descriptions of endpoints,  by defining a class (or an object) extending the endpoint  descriptions and mixing the interpreter trait.</li>
</ol>
<p>These relationships are illustrated by the following diagram:</p>
<p><img src="/interactions.svg" alt="interactions" /></p>
<p>The traits provided by endpoints4s are shown in gray.</p>
<h3><a href="#authentication-client-interpreter" name="authentication-client-interpreter" class="anchor"><span class="anchor-link"></span></a>Authentication client interpreter</h3>
<p>The implementation of the client interpreter repeats the same recipe: we define a trait <code>ClientAuthentication</code>, which extends <code>Authentication</code> and mixes a <code>client.Endpoints</code> base interpreter:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L20-L201" target="_blank" title="Go to snippet source">source</a><code class="language-scala">import endpoints4s.http4s.client

/** Interpreter for the [[Authentication]] algebra interface that produces
  * an http4s client (using `org.http4s.client.Client`).
  */
trait ClientAuthentication[F[_]]
    extends client.Endpoints[F]
    with client.JsonEntitiesFromSchemas
    with Authentication {

  def publicKey: PublicKey

  // The constructor is private so that users can not
  // forge instances themselves
  class AuthenticationToken private[ClientAuthentication] (
      private[ClientAuthentication] val token: String,
      val decoded: UserInfo
  )

  // Decodes the user info from an OK response
  def authenticationTokenCodec: Codec[String, AuthenticationToken] =
    Codec.fromEncoderAndDecoder[String, AuthenticationToken](_.token) { token =&gt;
      Validated.fromTry(
        JwtCirce
          .decode(token, publicKey)
          .flatMap(claim =&gt;
            io.circe.parser
              .parse(claim.content)
              .toTry
              .flatMap(
                _.as[UserInfo].toTry.map(userInfo =&gt; new AuthenticationToken(token, userInfo))
              )
          )
      )
    }


}</code></pre>
<p>The <code>AuthenticationToken</code> type is implemented as a class whose constructor is private. If it was public, clients could build a fake authentication token which would then fail at runtime because the server would reject it when seeing that it is not correctly signed. By making the constructor private, we make it impossible to reach such a runtime error.</p>
<p>The <code>AuthenticationToken</code> class contains the serialized token as well as the decoded <code>UserInfo</code>.</p>
<p>The <code>authenticationTokenCodec</code> operation is implemented as the dual of the server interpreter: it tries to decode the JWT, and then tries to parse its content and to decode it as a <code>UserInfo</code> object.</p>
<p>In case of failure, it returns an <a href="../api/endpoints4s/Invalid.html" title="endpoints4s.Invalid"><code>Invalid</code></a> value, which will ultimately been reported to the user by throwing an exception. One could argue that we should model the fact that decoding the response can fail by returning an <code>Option</code> instead of throwing an exception. However, the philosophy of endpoints4s is that client and server interpreters implement a same HTTP protocol, therefore we expect (and assume) the interpreters to be consistent together. Thus, we assume that donât need to surface that kind of failures (hence the use of exceptions).</p>
<p>This contrasts with the <code>wheneverValid</code> operation, which models the fact that the API key supplied by the user can be invalid. In such a case, we really want the failure to surface to the end-user, hence the usage of <code>Option</code>.</p>
<h3><a href="#putting-things-together-authentication-" name="putting-things-together-authentication-" class="anchor"><span class="anchor-link"></span></a>Putting things together (authentication)</h3>
<p>If we create an instance of our <code>Client</code> and run our <code>Server</code>, we can test that the following scenarios work as expected:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/test/scala/authentication/AuthenticationTest.scala#L91-L100" target="_blank" title="Go to snippet source">source</a><code class="language-scala">&quot;wrong login using client&quot; in {
  for {
    loginResult &lt;- client.login.sendAndConsume(&quot;unknown&quot;)
  } yield assert(loginResult.isEmpty)
}
&quot;valid login using client&quot; in {
  for {
    loginResult &lt;- client.login.sendAndConsume(&quot;foobar&quot;)
  } yield assert(loginResult.nonEmpty)
}</code></pre>
<p>These tests check that if we login with an unknown API key we get no authentication token, but if we login with the <code>&quot;foobar&quot;</code> API key then we get some authentication token.</p>
<h2><a href="#protected-endpoints" name="protected-endpoints" class="anchor"><span class="anchor-link"></span></a>Protected endpoints</h2>
<p>Now that we are able to issue an authentication token, letâs see how we can define endpoints that require such an authentication token to be present (and valid) in incoming requests.</p>
<p>Such protected endpoints take requests containing the serialized token in their <code>Authorization</code> HTTP header, and return a 401 (<code>Unauthorized</code>) response in case the token is not found or is invalid.</p>
<h3><a href="#protected-endpoints-algebra" name="protected-endpoints-algebra" class="anchor"><span class="anchor-link"></span></a>Protected endpoints algebra</h3>
<p>To define protected endpoints, we need to enrich the <code>Authentication</code> algebra with additional vocabulary. First, we need a way to define that requests that must contain the authentication token. Second, we need a way to define that responses might be <code>Unauthorized</code>. Last, we need a convenient <code>Endpoint</code> constructor that puts all the pieces together.</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L66-L113" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/** A request with the given `method`, `url` and `entity`, and which is rejected by the server if it
  * doesnât contain a valid JWT.
  */
private[authentication] def authenticatedRequest[U, E, UE, UET](
    method: Method,
    url: Url[U],
    entity: RequestEntity[E]
)(implicit
    tuplerUE: Tupler.Aux[U, E, UE],
    tuplerUET: Tupler.Aux[UE, AuthenticationToken, UET]
): Request[UET]

/** A response that might signal to the client that his request was not authenticated.
  * Clients throw an exception if the response status is `Unauthorized`.
  * Servers build an `Unauthorized` response in case the incoming request was not correctly authenticated.
  */
private[authentication] def wheneverAuthenticated[A](
    response: Response[A]
): Response[A]

/** User-facing constructor for endpoints requiring authentication.
  *
  * @return An endpoint requiring a authentication information to be provided
  *         in the `Authorization` request header. It returns `response`
  *         if the request is correctly authenticated, otherwise it returns
  *         an empty `Unauthorized` response.
  *
  * @param method        HTTP method
  * @param url           Request URL
  * @param response      HTTP response
  * @param requestEntity HTTP request entity
  * @tparam U Information carried by the URL
  * @tparam E Information carried by the request entity
  * @tparam R Information carried by the response
  */
final def authenticatedEndpoint[U, E, R, UE, UET](
    method: Method,
    url: Url[U],
    requestEntity: RequestEntity[E],
    response: Response[R]
)(implicit
    tuplerUE: Tupler.Aux[U, E, UE],
    tuplerUET: Tupler.Aux[UE, AuthenticationToken, UET]
): Endpoint[UET, R] =
  endpoint(
    authenticatedRequest(method, url, requestEntity),
    wheneverAuthenticated(response)
  )</code></pre>
<p>The <code>authenticatedRequest</code> method defines a request expecting an authentication token to be provided in the <code>Authorization</code> header. The <code>wheneverAuthenticated</code> method transforms a given <code>Response[A]</code> into another <code>Response[A]</code> that can be an <code>Unauthorized</code> HTTP response in case the client was not authenticated. Note that, in contrast with the previously defined <code>wheneverValid</code> method, we return a <code>Response[A]</code> rather than a <code>Response[Option[A]]</code>. This is because we assume that requests will be built by using the same algebra, which will make them correctly authenticated by construction.</p>
<p>The last operation we have introduced is <code>authenticatedEndpoint</code>, which takes a request and a response and wraps the request constituents into the <code>authenticatedRequest</code> constructor, and wraps the response into the <code>wheneverAuthenticated</code> combinator.</p>
<p>This <code>authenticatedEndpoint</code> operation is final, and it is the only user-facing operation for defining protected endpoints (the two other operations are private). It guarantees that the request will always have the authentication token in its headers, and that the response can always be <code>Unauthorized</code>.</p><div class="callout note "><div class="callout-title">Note</div>
<p>The <code>authenticatedRequest</code> operation takes several type parameters. In particular, they model the type of the request URL (<code>U</code>) and entity (<code>E</code>). These types must be tracked by the type system so that, eventually, an <code>Endpoint[Req, Resp]</code> is built, where the <code>Req</code> type is a tuple of all the information (URL and entity) carried by the request. In this example we enrich the request headers with the authentication token. However, instead of simply returning nested tuples (e.g. <code>((U, E), AuthenticationToken)</code>), we rely on implicit <code>Tupler</code> instances to compute the type of the tuple. <code>Tupler</code> instances are defined in a way that always flattens nested tuples (e.g. they will return <code>(U, E, AuthenticationToken)</code>) and removes <code>Unit</code> types (e.g. if the URL is staticâof type <code>Url[Unit]</code>âthe tuplers return <code>(E, AuthenticationToken)</code>).</p></div>
<p>The <code>authenticatedEndpoint</code> operation can be used as follows:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Usage.scala#L31-L41" target="_blank" title="Go to snippet source">source</a><code class="language-scala">/** Some resource requiring the request to provide a valid JWT token. Returns a message
  * âHello &#39;&#39;user_name&#39;&#39;â if the request is correctly authenticated, otherwise returns
  * an `Unauthorized` HTTP response.
  */
val someResource: Endpoint[AuthenticationToken, String] =
  authenticatedEndpoint(
    Get,
    path / &quot;some-resource&quot;,
    emptyRequest,
    ok(textResponse)
  )</code></pre>
<p>Since the request URL is static and the request has no entity, the information carried by the request is just the <code>AuthenticationToken</code>.</p>
<h3><a href="#protected-endpoints-server-interpreter" name="protected-endpoints-server-interpreter" class="anchor"><span class="anchor-link"></span></a>Protected endpoints server interpreter</h3>
<p>Our http4s-based server is implemented as follows:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L236-L299" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def authenticatedRequest[U, E, UE, UET](
    method: Method,
    url: Url[U],
    entity: RequestEntity[E]
)(implicit
    tuplerUE: Tupler.Aux[U, E, UE],
    tuplerUET: Tupler.Aux[UE, AuthenticationToken, UET]
): Request[UET] = {
  // Extracts and validates user info from a request header
  val authenticationTokenRequestHeaders: RequestHeaders[Option[AuthenticationToken]] = {
    headers =&gt;
      {
        Valid(
          headers
            .get[Authorization]
            .flatMap {
              case Authorization(Credentials.Token(AuthScheme.Bearer, token)) =&gt;
                decodeToken(token).toEither.toOption
              case _ =&gt; None
            }
        )
      }
  }

  new Request[UET] {

    // Data extracted from the incoming request
    type UrlAndHeaders = (U, AuthenticationToken)

    def matchAndParseHeaders(
        http4sRequest: org.http4s.Request[F]
    ): Option[Either[org.http4s.Response[F], Validated[UrlAndHeaders]]] =
      // First, check whether the incoming request matches this request description
      matchAndParseHeadersAsRight(method, url, emptyRequestHeaders, http4sRequest)
        // If this is the case, check whether there is a token in the request headers or not
        .map { errorResponseOrValidatedUrl =&gt;
          authenticationTokenRequestHeaders(http4sRequest.headers) match {
            // There is a token, just add it to the data parsed from the URL
            case Valid(Some(token)) =&gt;
              errorResponseOrValidatedUrl
                .map { validatedUrl =&gt;
                  validatedUrl.map { case (urlData, _) =&gt; (urlData, token) }
                }
            // Otherwise, return an Unauthorized response
            case _ =&gt; Left(org.http4s.Response(Unauthorized))
          }
        }

    def parseEntity(
        urlAndHeaders: UrlAndHeaders,
        http4sRequest: org.http4s.Request[F]
    ): Effect[Either[org.http4s.Response[F], UET]] =
      entity(http4sRequest).map(_.map { entityData =&gt;
        val (urlData, token) = urlAndHeaders
        tuplerUET(tuplerUE(urlData, entityData), token)
      })

  }
}

// Does nothing because `authenticatedReqest` already
// takes care of returning `Unauthorized` if the request
// is not properly authenticated
def wheneverAuthenticated[A](response: Response[A]): Response[A] = response</code></pre>
<p>And the protected endpoint can be implemented as follows:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Usage.scala#L92-L94" target="_blank" title="Go to snippet source">source</a><code class="language-scala">// Note that the `AuthenticationToken` is available to the implementations
// It can be used to check authorizations
someResource.implementedBy(token =&gt; s&quot;Hello ${token.name}!&quot;)</code></pre>
<h3><a href="#protected-endpoints-client-interpreter" name="protected-endpoints-client-interpreter" class="anchor"><span class="anchor-link"></span></a>Protected endpoints client interpreter</h3>
<p>And our http4s-based client is implemented as follows:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/main/scala/authentication/Authentication.scala#L172-L197" target="_blank" title="Go to snippet source">source</a><code class="language-scala">def authenticatedRequest[U, E, UE, UET](
    method: Method,
    url: Url[U],
    entity: RequestEntity[E]
)(implicit
    tuplerUE: Tupler.Aux[U, E, UE],
    tuplerUET: Tupler.Aux[UE, AuthenticationToken, UET]
): Request[UET] = {
  // Encodes the user info as a JWT object in the `Authorization` request header
  val authenticationTokenRequestHeaders: RequestHeaders[AuthenticationToken] = {
    (user, http4sRequest) =&gt;
      http4sRequest.putHeaders(
        Authorization(Credentials.Token(AuthScheme.Bearer, user.token))
      )
  }
  request(method, url, entity, headers = authenticationTokenRequestHeaders)
}

// Checks that the response is not `Unauthorized` before continuing
def wheneverAuthenticated[A](response: Response[A]): Response[A] = { (status, headers) =&gt;
  if (status == Unauthorized) {
    Some(_ =&gt; effect.raiseError(new Exception(&quot;Unauthorized&quot;)))
  } else {
    response(status, headers)
  }
}</code></pre>
<h3><a href="#putting-things-together-protected-endpoints-" name="putting-things-together-protected-endpoints-" class="anchor"><span class="anchor-link"></span></a>Putting things together (protected endpoints)</h3>
<p>Our <code>Client</code> and <code>Server</code> instances are now able to have more sophisticated exchanges:</p>
<pre class="prettyprint"><button class="snippet-button copy-snippet" title="Copy snippet to clipboard">copy</button><a class="snippet-button go-to-source" href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/examples/authentication/src/test/scala/authentication/AuthenticationTest.scala#L103-L110" target="_blank" title="Go to snippet source">source</a><code class="language-scala">&quot;login and access protected resource&quot; in {
  for {
    maybeToken &lt;- client.login.sendAndConsume(&quot;foobar&quot;)
    token = maybeToken.get
    _ = assert(token.decoded == UserInfo(&quot;Alice&quot;))
    resource &lt;- client.someResource.sendAndConsume(token)
  } yield assert(resource == &quot;Hello Alice!&quot;)
}</code></pre>
<p>This test first gets an authentication token by calling the <code>login</code> endpoint, and then accesses the protected endpoint by supplying its token.</p>
<h2><a href="#conclusion" name="conclusion" class="anchor"><span class="anchor-link"></span></a>Conclusion</h2>
<p>This page shows how to include an application-specific aspect of the communication protocol at the algebra level, and how to implement interpreters for this extended algebra.</p>
<p>We only demonstrated how to implement client and server interpreters but the same approach can be used with documentation interpreters.</p>
</div>
<div>
<a href="https://github.com/endpoints4s/endpoints4s/tree/master/documentation/manual/src/main/paradox/guides/custom-authentication.md" title="Edit this page" class="md-source-file md-edit">
Edit this page
</a>
</div>
<div class="print-only">
<span class="md-source-file md-version">
1.9.0
</span>
</div>
</article>
</div>
</div>
</main>
<footer class="md-footer">
<div class="md-footer-nav">
<nav class="md-footer-nav__inner md-grid">
<a href="../guides/tupler.html" title="Tupler" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
</div>
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Previous
</span>
Tupler
</span>
</div>
</a>
<a href="../community.html" title="Community" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
<div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
<span class="md-flex__ellipsis">
<span class="md-footer-nav__direction">
Next
</span>
Community
</span>
</div>
<div class="md-flex__cell md-flex__cell--shrink">
<i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
</div>
</a>
</nav>
</div>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-footer-copyright">
Powered by
<a href="https://github.com/lightbend/paradox">Paradox</a>
and
<a href="https://jonas.github.io/paradox-material-theme/">Paradox Material Theme</a>

</div>
<div class="md-footer-social">
<a href="https://github.com/endpoints4s/endpoints4s" class="md-footer-social__link fa fa-github"></a>
</div>

</div>
</div>
</footer>

</div>
<script src="../assets/javascripts/application.583bbe55.js"></script>
<script src="../assets/javascripts/paradox-material-theme.js"></script>
<script>app.initialize({version:"0.17",url:{base:"../."}})</script>
<script type="text/javascript" src="../lib/prettify/prettify.js"></script>
<script type="text/javascript" src="../lib/prettify/lang-scala.js"></script>
<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function(event) {
window.prettyPrint && prettyPrint();
});
</script>
</body>
</html>
